import "platform:/resource/org.moflon.handbook.learningboxlanguage/model/Learningboxlanguage.ecore"
import "http://www.eclipse.org/emf/2002/Ecore"

package org.moflon.handbook.learningboxlanguage


class Box {
    operation grow() : void {
        // Pattern invocation
        if(addNewPatternToBox(this : Box))
        {
            return true
        } else {
            // Operation invocation
            if(this.initializeBox()) {
                return true
            } else {
                return false
            } 
        }
    }
    
    pattern addNewPatternToBox(box : Box) {
        firstPartitionInBox : Partition
        lastPartitionInBox : Partition
        
        ++ newPartition : Partition
        
        box : Box {
            -containedPartitions-> firstPartition
            -containedPartitions-> lastPartition
            ++ -containedPartitions-> newPartition
        }
        
        // Named NACs
        nac noPrevious {
            forbiddedPreviousPartition : Partition
            firstPartition : Partition {
                -previous->forbiddedPreviousPartition
            }
        }
        
        nac noNext {
            forbiddenNextPartition : Partition
            lastPartiion : Partition {
                -next-> forbiddenNextPartition
            }
        }
            
    }
    
    operation initializeBox() : EBoolean {
        if(buildPartitions(this : Box)) {
            return true
        } else {
            return false
        }
    }
    
    pattern buildPartitions(box : Box) {
        ++ firstPartition : Partition {
            -next-> lastPartition
        }
        
        ++ lastPartition : Partition {
            -previous-> firstPartition
        }
        
        box : Box {
            ++ -containedPartitions-> firstPartition
            ++ -containedPartitions-> lastPartition
        }    
        
        nac {
            forbiddenPartition : Partition {
                -box-> box
            }
        }
    }
    
    operation toString() : EString {
        for(allPartitions(this : Box, partition : Partition))
        {
            for(allCards(partition : Partition, card : Card)) {
                this.addToStringRep(card);
            }
        }    
        return this.stringRep
    }
    
    pattern allPartitions(box : Box, partition : Partition) {
        box : Box {
            -containedPartitions-> partition
        }
    }
    
    pattern allCards(partition : Partition, card : Card) {
        partition : Partition {
            -card-> card
        }
    }
    
    // Handled via injection
    operation addToStringRep() : void
    
    // Handled via injection
    operation determineNextSize() : EInt   
}

class Card {

    operation invert() : void {
        tempCard : Card
        invoke initializeTempCard(this : Card, tempCard : Card)
        invoke swapVariables(this : Card, tempCard : Card)
    }
    
    pattern initializeTempCard(this : Card, tmp : Card) {
        constraints {
            eq(this.face, tmp.back)
            eq(tmp.face, this.back)
        }
    }
    
    pattern swapVariables(this : Card, tempCard : Card) {
        constraints {
            eq(this.face, tempCard.back)
            eq(this.back, tempCard.face)
        }
    }
    
    // Handled by injection
    operation printCard() : void
    
    
}


class Partition {
    operation check(card : Card, guess : EString) : EBoolean {
        if(checkCard(card, guess)) {
            if (isFastCard(card)) {
                invoke promoteFastCard(card)
            }
            else {
                invoke promoteCard(card)
            }
        } else {
            invoke penalizeCard(card)
        }
    } 
    
    pattern checkCard(card : Card, guess : EString) {
        constraints {
            eq(card.face, guess)
        }
    }
    
    pattern isFastCard(card : Card) {
        card : FastCard
    }
    
    pattern promoteFastCard(card : FastCard) {
        currentPartition : Partition 
        futurePartition : Partition
        card : Card {
            -- -cardContainer-> currentPartition
            ++ -cardContainer-> futurePartition
        }
        constraints {
            +(futurePartition.partitionSize', futurePartitionSize, 1)
            -(currentPartition.partitionSize', currentPartition, 1)
        }
        
        nac noNextPartition {
            forbiddenNextPartition : Partition
            futurePartition : Partition {
                -next-> forbiddenNextPartition
            }            
        }
        
    }
    
    pattern promoteCard(card : Card) {
        currentPartition : Partition {
            -next-> futurePartition
        } 
        futurePartition : Partition 
        card {
            -- -cardContainer-> currentPartition
            ++ -cardContainer-> futurePartition
        }
        
        // Attribute constraints
        constraints {
            +(futurePartition.partitionSize', futurePartitionSize, 1)
            -(currentPartition.partitionSize', currentPartition, 1)
        }
    }
    
    pattern penalizeCard(card : Card) {
        currentPartition : Partition {
            -previous-> currentPartition
        }
        futurePartition : Partition 
        card {
            -- -cardContainer-> currentPartition
            ++ -cardContainer-> futurePartition
        }
        constraints {
            +(futurePartition.partitionSize', futurePartitionSize, 1)
            -(currentPartition.partitionSize', currentPartition, 1)
        }
    }
    
    operation empty() : void {
        for(deleteCard(this : Partition))
    }
   
    pattern deleteCard(partition : Partition) {
        -- card : Card {
            -cardContainer-> partition
        }
    }
   
    operation removeCard(card : Card) : Card {
        invoke removeCard(this: Partition, card : Card)
        return card
    }
    
    pattern removeCard(partition : Partition, card : Card) {
        partition : Partition {
            -- -card-> card
        }
        
        card : Card {
            -- -cardContainer-> partition
        }
    }
}
